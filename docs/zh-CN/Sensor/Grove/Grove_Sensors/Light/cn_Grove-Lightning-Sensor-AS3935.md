---
description: Grove闪电传感器AS3935入门指南
title: Grove闪电传感器AS3935
keywords:
- lightning
image: https://files.seeedstudio.com/wiki/seeed_logo/logo_2023.png
slug: /cn/grove-lightning-sensor-as3935
last_update:
  date: 06/07/2023
  author: Citric
---

<div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Grove-lightning-sensor/6.jpg" style={{width:400, height:'auto'}}/></div>

<div class="get_one_now_container" style={{textAlign: 'center'}}>
    <a class="get_one_now_item" href="https://www.seeedstudio.com/Grove-Lightning-Sensor-AS3935-p-5603.html">
            <strong><span><font color={'FFFFFF'} size={"4"}> 立即购买 🖱️</font></span></strong>
    </a>
</div>

<br />

## 介绍

Grove闪电传感器是一款高度敏感的传感器，能够检测空气中的自由电场，并使用内部专有算法确定电场是否由雷暴闪电事件的前沿引起。它非常易于使用，采用Grove标准连接线作为即插即用设备，可以接受多种调整以针对室内或室外应用环境进行优化。

该传感器的用途是对即将到来的雷暴闪电前沿进行预防性警报，以避免对电气设备或人员造成伤害，还可用于天气研究，因为它可以提供关于闪电事件强度和数量的多种数据。该传感器可以与天气预报站中的其他传感器完全集成，在农业中对于在即将到来的雷暴中保护作物非常有用。可以检测到30-40公里距离的雷暴闪电前沿，即使还看不到雷暴。

### 特性

- 极其紧凑且易于使用的传感器。

- 对空气中的电场非常敏感，仅选择符合闪电前沿典型波形的电场，其他的将被拒绝。

- 通过I2C协议通信，与Arduino、Seeeduino或树莓派开发板接口简单。

- 极低功耗，可进入睡眠模式以降低功耗并延长电池寿命。

- 每次验证闪电前沿时，在IRQ引脚上发送中断信号。对微控制器连接和软件控制很有用。

- Grove系统完全兼容接口。

- 易于集成到天气站或警报设备中，以防止电子设备或人员受伤。

## 硬件概述

在开始之前，了解产品的一些基本参数是非常重要的。下表提供了Grove闪电传感器特性的信息。

### 技术规格

<table align="center">
	<tr>
	    <th align="center">参数</th>
	    <th align="center">范围/数值</th>
	</tr>
	<tr>
	    <td align="center">输入电压</td>
	    <td align="center">5伏或3.3伏（选择适当的焊接 
 焊盘）</td>
	</tr>
	<tr>
	    <td align="center">通信方式</td>
	    <td align="center">I2C标准，使用提供的输出的SPI</td>
	</tr>
	<tr>
	    <td align="center">最大检测范围</td>
	    <td align="center">40公里</td>
	</tr>
	<tr>
	    <td align="center">可编程</td>
	    <td align="left">是，可以编程适当的寄存器以适应传感器安装的应用和环境。</td>
	</tr>
</table>

## 入门指南

### 模块电源选择

Grove闪电传感器支持两种不同的供电电压 - 5V和3.3V。您需要确定您的供电电压并在使用模块之前进行简单的焊接。

如果您选择**5伏**供电，请将Grove闪电传感器上的焊盘(5V)和(0)焊接在一起，如下图所示。

<div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Grove-lightning-sensor/1.png" style={{width:500, height:'auto'}}/></div>

如果您选择**3.3伏**供电，请将Grove闪电传感器上的焊盘焊接在一起，如下图所示。如果您使用在3.3伏下工作的Seeed Arduino Breakout for Linkt Smart 7688 Duo开发板，就是这种情况。

<div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Grove-lightning-sensor/2.png" style={{width:500, height:'auto'}}/></div>

:::note
Grove闪电传感器可以承受在开发板供电**开启**状态下的热插拔，但不建议这样做，在将Grove闪电传感器连接到开发板连接器之前，请始终关闭供电。
:::

## Arduino示例

这里提供的Arduino代码允许与传感器对话并修改所有相关寄存器，这些寄存器决定了操作期间的最佳行为。传感器配备了基础寄存器值，如代码中详细描述的那样，这是应用的良好起点。需要一些工作来获得与应用的最佳匹配，这是使用传感器的一项非常具有挑战性的工作，因为它显示出对使用环境的极强适应性。

**步骤1.** 启动Arduino应用程序。

<div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/seeed_logo/arduino.jpg" style={{width:800, height:'auto'}}/></div>

**步骤2.** 选择您的开发板型号并将其添加到Arduino IDE。

- 如果您想在后续程序中使用**Seeeduino**，请参考[此教程](https://wiki.seeedstudio.com/cn/Seeed_Arduino_Boards/)来完成添加。

- 如果您想在后续程序中使用**Seeed Studio XIAO SAMD21**，请参考[此教程](https://wiki.seeedstudio.com/cn/Seeeduino-XIAO/#software)来完成添加。

- 如果您想在后续程序中使用**Seeed Studio XIAO RP2040**，请参考[此教程](https://wiki.seeedstudio.com/cn/XIAO-RP2040-with-Arduino/#software-setup)来完成添加。

- 如果您想在后续程序中使用**Seeed Studio XIAO nRF52840**，请参考[此教程](https://wiki.seeedstudio.com/cn/XIAO_BLE/#software-setup)来完成添加。

- 如果您想在后续程序中使用**Seeed Studio XIAO ESP32C3**，请参考[此教程](https://wiki.seeedstudio.com/cn/XIAO_ESP32C3_Getting_Started/#software-setup)来完成添加。

### 演示：在Seeeduino上使用Grove闪电传感器

#### 所需材料

| Seeeduino V4.3 |  Grove - 闪电传感器AS3935 |
|:--------------:|:--------------:|
| <div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/SeeeduinoV4/images/cover.JPG" style={{width:250, height:'auto'}}/></div> | <div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Grove-lightning-sensor/6.jpg" style={{width:250, height:'auto'}}/></div> |
|[**立即购买**](https://www.seeedstudio.com/Seeeduino-V4-2-p-2517.html)|[**立即购买**](https://www.seeedstudio.com/Grove-Lightning-Sensor-AS3935-p-5603.html)|

:::caution
请在使用前检查传感器的前焊盘是否已焊接。如果图片中所示位置未焊接，您在后面执行程序时可能会遇到IIC设备未被检测到的问题。

<div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Grove-lightning-sensor/7.jpg" style={{width:400, height:'auto'}}/></div>
:::

**步骤3**. 将Grove闪电传感器连接到Seeeduino V4的I2C端口。

<div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Grove-lightning-sensor/3.jpg" style={{width:700, height:'auto'}}/></div>

**步骤4**. 通过Micro-USB线将Seeeduino连接到PC。

**步骤5**. 将以下程序上传到Seeeduino。

<details>

<summary>点击这里预览完整代码</summary>

```cpp
//*********************************************************************************
//***************  专为Seeed Grove传感器开发设计 *******************
//***************  GROVE   FRANKLYN闪电传感器AS3935     *******************
//***************  闪电前沿检测传感器     ******************* 
//***************                                               *******************
//*************** 首次发布: 1.0 - 10/15/2022               ******************* 
//*************** 作者: Davide Cogliati                       *******************
//*********************************************************************************
//
//工作摘要：
//------------------------------------------------------------------------------------------------------
//这个GROVE传感器板集成了AS3935，这是一个可编程的完全集成的闪电
//传感器IC，它检测附近闪电活动的接近并提供到雷暴头部距离的估计。
//在AS3935中有一个嵌入式闪电算法，它检查传入信号的时间形式并拒绝潜在的
//人为干扰作为错误警报。
//AS3935还可以提供噪声水平信息，并在高噪声条件下通知外部微控制器，
//使用噪声基底生成器和噪声基底评估块。这些后续功能可通过内部寄存器
//编程以优化传感器本身的现场工作（室内、室外）。
//AS3935可以通过I²C或4线标准SPI编程。与I²C一起，还可以在三个不同的
//地址(0X01, 0X02, 0X03)中选择。两个时钟由两个不同的RC振荡器内部生成：
//TRCO和SRCO，并且可以在传感器开启时随时运行自动校准程序以提高这些
//振荡器的精度。
//该板可以通过在板上选择正确的跳线设置由5伏或内部3.3伏电压调节器供电。
//该板对电磁场非常敏感，因此可能会检测到意外峰值或错误闪电，当然
//内部寄存器的设置可以优化错误触发事件。如果微处理器通过I²C总线和
//板上提供的IRQ引脚连接到板，闪电警报可以以最佳方式管理，通过编写
//适当的算法还可以实现对事件的过滤。
//这个板是通过在IRQ引脚输出上连接示波器并运行ARDUINO GUI的串行绘图器
//和串行监视器进行测试的，然后模拟干扰动作或模拟闪电以使设备适当触发。
//实验结果分析显示对事件的极高敏感性和AS3935内部固件捕获干扰或模拟
//闪电的能力。当然在测试期间，修改了内部寄存器以观察响应如何变化。
//
//-----------------------------------------------------------------------------------------------------
//代码设计理念:                     ---------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------
//这个代码被设计为提供一种简单的方式来使用AS3935 Grove传感器，
//所有功能都在一个代码中。这个代码是如何直接使用传感器功能的示例，
//优化寄存器内容以影响传感器的最终行为。使用这个代码让您也能
//管理数据输出，可以使用串行监视器以纯文本形式或使用ARDUINO GUI
//中的串行绘图器以图形方式输出。
//只需要1个库，"#include <Wire.h>  //用于I2C模式通信总线"，
//以使所有事情变得非常简单，所有其他软件功能都是手写的。
//
//这个代码提供传感器内部寄存器的测试和I2C设备地址识别程序，
//以测试板子A0、A1跳线的焊接以更改设备地址。
//这个代码不管理SPI功能通信端口，而是管理I2C端口，这是GROVE标准。
//要使用SPI端口，板上提供了一些跳线和焊接跳线（SI跳线），
//板的一侧放置了用于SPI连接的4路连接器焊盘。
//
//这个板可以在5.0伏或3.3伏供电下工作，以优化与微控制器供电电压的接口。
//要选择其中一种供电，板上提供了简单的跳线选择系统，标准供电是5.0伏。
//如果将使用SPI通信端口，应该修改这个代码的通信指令以使用SPI而不是I2C，
//并且应该使用ARDUINO免费的"#include <SPI.h>  //用于SPI模式通信总线"
//而不是"#include <Wire.h>"。
//这个代码是为了快速使用传感器AS3935而不需要了解许多功能，
//但当然可以进行所有必要的修改以适应应用中的最终使用。
//----------------------------------------------------------------------------------------------------
//
//********************************************************************************
//********************************************************************************
//********************************************************************************

#include <Wire.h>  //用于I2C模式通信总线

//------------------------------------------------------------------------------------------------
//bit0= 0  0= 开机 ------> 手动设置为传感器关机状态 !!!
//         1= 关机
//bit 1..5= AFE (增益) = 10010 (默认值)
//室内  10010 建议
//室外 01110 建议
//-----------------------------------------------------------------------------------------------
#define INDOOR            0b00100100 //开机 bit0= 0
#define OUTDOOR           0b00011100 //开机 bit0= 0
//-----------------------------------------------------------------------------------------------
#define DIRECT_COMMAND    0x96 //在以下寄存器中写入此值以操作命令
//---------------------------------
//  动作                 寄存器
//---------------------------------
//  PRESET_DEFAULT          0x3C
//  CALIB_RCO               0x3D
//---------------------------------
//--------------------------------------------------
//全局变量
//--------------------------------------------------
 char REG0X02reset_startup ;         //在工作操作中重置统计时使用
 char REG0X02reset_startup_up ;      //用于启动传感器
 char REG0X02reset_startup_down ;    //用于关闭传感器

//-----------------------------------------------------------------------------
//查看ARDUINO串行输出结果非常重要          -----------
//-----------------------------------------------------------------------------
//设置ARDUINO显示模式：
//直接在ARDUINO GUI中选择"串行监视器"或"串行绘图"
//----------------------------------------------------------------------------
//+) 串行监视器   = 以易读格式的数据流和变量读出
//+) 串行绘图  = 显示闪电事件和其他变量的绘图
//--------------------------------------------------------------------------------------------------------
char LITERAL_mode =1;  //0= 在串行监视器中不打印数据,    1= 是在串行监视器上打印数据
char GRAPH_mode =0;    //0= 在串行绘图器中不显示图形数据,  1= 是在串行绘图器中显示图形数据
//--------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
//I2C地址扫描器 - 查找器          |
//---------------------------------------
//检查有效AS3935传感器在线的存在（这部分在最终应用中可以省略，
//但在首次设置I2C地址时使用它）
//----------------------------------------------------------------------------------
void setup()
{
  Serial.begin(9600); 
  
  if (LITERAL_mode ==1)
      {
      Serial.println("AS3935 闪电传感器| i2C扫描器");
      Serial.println("启动中....");
      Serial.println("------------------------------------");
      delay(1000);
      }
  Wire.begin();
  Wire.setClock(100000); // 设置I2C速度 

}

//------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------
void loop()
{
  int c;
  int indevice;   //设备号I2C地址，在最终应用中您可以直接分配
                  //地址（例如: indevice = 3;）
 
  //---------------------------------------------------
  // I2C模式的读/写函数:
  //---------------------------------------------------
  //**************************************************************************
  //**************************************************************************
  int done =1;       //开始I2C传感器地址自检的标志
    indevice = 0;    //重置地址值
    while (done)
    {

     
    indevice = indevice +1 ; 
    if (indevice > 7)
        indevice=0;
       
    Wire.requestFrom(indevice, 1);    // 从从设备请求1字节
    
    if (LITERAL_mode ==1)
      {
       Serial.print("扫描设备 = 0x0");         // 打印字符
       Serial.print(indevice);       
       Serial.println(" ");
      }
    delay(250);
  
    //-----------------------------------------------------------
    // 扫描并找到有效地址显示寄存器内容
    //-----------------------------------------------------------
    //-----------------------------------------------------------
    while(Wire.available()) 
    {
        c = Wire.read();    // 接收字节作为字符
        if (LITERAL_mode ==1)
         {
           Serial.println();               
           Serial.print("数据=.......... 有效地址 .................. ");  // 打印接收到的字符
           Serial.println();             
           Serial.print("找到地址: 0X0");
           Serial.print(indevice);
           Serial.print(" -->  应答: ");
           Serial.print("[ ");
           Serial.print((int)c);         // 打印字符
           Serial.print(" ]");           
         }  
        //-------------------------------------------------------------------------------------------------
        //设置I2C地址的寄存器: A0 & A1 使用GROVE传感器A0、A1上的焊接跳线
        //-------------------------------------------------------------------------------------------------
        //A0        A1         ADR  0X0 
        //****************************************************
        //焊接   焊接    < 不允许 !!!!>         *****
        //焊接   否        0X01    ;焊接跳线A0      *****
        //否       焊接    0X02    ;焊接跳线A1      *****
        //否       否        0X03    ;未焊接跳线   *****
        //----------------------------------------------------
        //--------------------------------------------------------------------------------------------
        //AS3935的设置和结果寄存器列表       --------------------------------
        //--------------------------------------------------------------------------------------------
        //AS3935_寄存器名称     |  写=W / 读=R  |   保留位 = x, 可修改位= a
        //--------------------------------------------------------------------------------------------
        // AFE_GAIN          = 0x00     W/R                 > XXaa aaaa                            
        // THRESHOLD,        = 0X01     W/R                 > aaaa aaaa
        // LIGHTNING_REG     = 0X02     W/R                 > Xaaa aaaa
        // INT_MASK_ANT      = 0X03     W/R                 > aaaa Xaaa
        // ENERGY_LIGHT_LSB  = 0X04     R                   > -
        // ENERGY_LIGHT_MSB  = 0X05     R                   > -
        // ENERGY_LIGHT_MMSB = 0X06     R                   > -
        // DISTANCE          = 0X07     R                   > -
        // DISP /TUNING CAP  = 0X08     W/R                 > aaaa aaaa
        // CALIB_TRCO        = 0x3A     R                   > -
        // CALIB_SRCO        = 0x3B     R                   > -
        // PRESET            = 0x3C     W/R                 > aaaa aaaa  <--您可以在此寄存器中发送直接命令（设置所有为默认）!!!
        // CALIB_RCO         = 0x3D     W/R                 > aaaa aaaa  <--您可以在此寄存器中发送直接命令（自校准）!!!
        //--------------------------------------------------------------------------------------------
        //
        //--------------------------------------------------------------------------------------------
        //调整传感器并写入数据到选定寄存器!                 ----------------
        //--------------------------------------------------------------------------------------------
        //更多信息....请参考AS3935数据表!!!                        -----------------
        //--------------------------------------------------------------------------------------------
        //寄存器0X00: 位[0]和位[1..5]
        //----------------------------------------
          if (LITERAL_mode ==1)
          {  
            Serial.println();
            Serial.print("写入寄存器0x00 ");
          }  
        Wire.beginTransmission(indevice);
        Wire.write(0x00);
        //------------------------------
        //bit0= 0  开机 ------> 如果要将传感器置于关机状态请手动设置!!!
        //bit 1..5= AFE (增益) = 10010 (默认值)
        //室内  10010 建议
        //室外 01110 建议
        //------------------------------
        //字节 = 00 10010 0 (0x24 hex)
        //------------------------------
        //INDOOR  = 如果室内...
        //OUTDOOR = 如果室外...
        Wire.write(INDOOR);
        Wire.endTransmission(true);
        if (LITERAL_mode ==1)
           {   
             Serial.println();
             Serial.print("完成! ");
             Serial.println();
           }  
        delay(200);
        //------------------------------------------
        //寄存器0X01: 位[0..3]和位[4..6]
        //------------------------------------------
        if (LITERAL_mode ==1)
         { 
          Serial.println();
          Serial.print("写入寄存器0x01 ");
         }  
        Wire.beginTransmission(indevice);
        Wire.write(0x01);
        //-------------------------------------------------
        //bit0..3 看门狗阈值 = 0010 (默认值)
        //bit4..6 噪声基底水平  = 010  (默认值)
        //---------------------------------------------------------------------------------------------------------------------------------------------
        // 连续输入噪声水平 |[μVrms]              连续输入噪声水平                     REG0x01[6]  REG0x01[5]    REG0x01[4]
        //    [μVrms] (室外)                                        [μVrms] (室内)  
        //---------------------------------------------------------------------------------------------------------------------------------------------
        //      390                                                          28                                   0         0           0
        //      630                                                          45                                   0         0           1
        //      860                                                          62                                   0         1           0
        //      1100                                                         78                                   0         1           1
        //      1140                                                         95                                   1         0           0
        //      1570                                                         112                                  1         0           1
        //      1800                                                         130                                  1         1           0
        //      2000                                                         146                                  1         1           1
        //---------------------------------------------------------------------------------------------------------------------------------------------  
        //字节 = 0 010 0010 (0x22 hex)
        //-------------------------------------------------
        
        Wire.write(0b00100010);
        Wire.endTransmission(true);
        if (LITERAL_mode ==1)
        {  
          Serial.println();
          Serial.print("完成! ");
          Serial.println();
        } 
        delay(200);
        //-------------------------------------
        //寄存器0X02:
        //-------------------------------------
        if (LITERAL_mode ==1)
        {  
         Serial.println();
         Serial.print("写入寄存器0x02 ");
        }  
        Wire.beginTransmission(indevice);
        Wire.write(0x02);
        //-------------------------------------------------
        //bit0..3 尖峰抑制 = 0010 (默认值)    ------> 更大的值提供更多抑制
        //                                                  ------> 对干扰的抑制但降低敏感性
        //bit4..5 闪电数量 = 00 (默认值) ------> 您可以根据需要修改这2位
        //bit6   清除统计 = 1 (默认值)       ------> 清除内部收集的数据
        //字节 = 0 100 0010 (0x42 hex)
        //-------------------------------------------------
        REG0X02reset_startup_up =   0b01000010;   //在工作操作中重置统计时使用
        REG0X02reset_startup_down = 0b00000010;   //在工作操作中重置统计时使用
        REG0X02reset_startup   = 0b01000010;      //启动传感器时使用
        Wire.write( REG0X02reset_startup);
        Wire.endTransmission(true);
        if (LITERAL_mode ==1)
        {   
          Serial.println();
          Serial.print("完成! ");
          Serial.println();
        }  
        delay(200);
        //-------------------------------------
        //寄存器0X03:
        //-------------------------------------
          if (LITERAL_mode ==1)
      {     
        Serial.println();
        Serial.print("写入寄存器0x03");
       }  
        Wire.beginTransmission(indevice);
        Wire.write(0x03);
        //-------------------------------------------------
        //bit5    屏蔽干扰器  = 0 (默认值 -> 无屏蔽)
        //bit6..7 调谐频率分频比  = 00 (默认值)
        //所有其他位都是保留的或只读的!!!
        //字节 = 0 000 0000 (0x00 hex)
        //-------------------------------------------------
        Wire.write(0b00000000);
        Wire.endTransmission(true);
        if (LITERAL_mode ==1)
         {    
          Serial.println();
          Serial.print("完成! ");
          Serial.println();
         }  
        delay(200);
        //-----------------------------------------------------
        //寄存器0X08:
        //-----------------------------------------------------
        if (LITERAL_mode ==1)
        {   
          Serial.println();
          Serial.print("写入寄存器0x08 ");
        }  
        Wire.beginTransmission(indevice);
        Wire.write(0x08);
        //-------------------------------------------------
        //bit0..3 内部调谐电容器（从0到120pF，步进8pF）= 000 (默认值) ---> 获得与500 kHz谐振频率的最佳匹配
        //------------------------------------
        // 这里您给出想要开启的电容器值。它接受高达120pF，步进8pF: 8, 16, 24, 32等。频率变化
        // 有些适中。在最大值时，您可以将频率降低高达22kHz。作为起点，内部设计的产品在496kHz附近发货
        //（当然每个板子都不同）将您置于完美谐振的百分之一内；数据表规定在3.5%内为最佳。
        //
        //
        //bit5    在IRQ引脚上显示TRCO  = 0 (默认值) ---------> 设置为"1"以在板的INT引脚上启用频率方波输出!
        //bit6    在IRQ引脚上显示SRCO  = 0 (默认值) ---------> 设置为"1"以在板的INT引脚上启用频率方波输出!
        //bit7    在IRQ引脚上显示LCO   = 0 (默认值) ---------> 设置为"1"以在板的INT引脚上启用天线谐振频率方波输出!
        //-------------------------------------
        //TRCO - 定时器RCO振荡器1.1MHz
        //SRCO - 系统RCO在32.768kHz
        //LCO - 天线频率
        //-------------------------------------
        //字节 = 0 000 0000 (0x00 hex)
        //-----------------------------------------------------------------------------------------------------------------------------------
        //调试板硬件谐振频率的步骤:
        //--------------------------------------------------------------
        //1) 观察LCO 500 Khz中心谐振频率需要将示波器探头连接到Seed Grove AS3935的IRQ引脚
        //2) 然后设置位7= 1和位5=0, 位6=0;
        //3) 然后用这个代码编程后启动应用程序。
        //4) 最后测量的频率必须乘以内部分频因子，如下所示:
        //-----------------------------------------------------------------------------------------------------------------------------------
        // 分频比 REG0x03[7] REG0x03[6]
        //  16          0               0
        //  32          0               1
        //  64          1               0
        //  128         1               1
        //-------------------------------------------------------------------------------------------------------------------------------
        //在这种情况下分频比= 16，所以如果测量是31.9 kHz，这最终是510.4 kHz（31.9 x 16），
        //是2.0%的变化，这是可以的，因为数据表建议保持< 3.5%以获得板的最佳结果。
        //--------------------------------------------------------------------------------------------------------------------------------
        Wire.write(0b00000000);  //要在IRQ引脚上获得LCO请编程(0b10000000)
        Wire.endTransmission(true);
        if (LITERAL_mode ==1)
         { 
           Serial.println();
           Serial.print("完成! ");
           Serial.println();
         } 
        delay(200);
        //***************************************************************************
        //------------------------------------------------
        //向AS3935发出可选直接命令
        //------------------------------------------------
        //-----------------------------------------------------------------------------------------------
        //  DIRECT_COMMAND    0x96 //在以下寄存器中写入此值以操作命令
        //---------------------------------
        //  动作                 寄存器
        //---------------------------------
        //  PRESET_DEFAULT          0x3C
        //  CALIB_RCO               0x3D
        //---------------------------------
             if (false)     //------> 写"true"激活直接命令
            { 
             Wire.beginTransmission(indevice);
             Wire.write(0x3C);
             Wire.write(0x96);
             Wire.endTransmission(true);
             if (LITERAL_mode ==1)
              {    
                Serial.println();
                Serial.print("完成预设默认! ");
                Serial.println();
               }  
             delay(1500);
            }
            //---------------------------------
            if (false)     //------> 写"true"激活直接命令
            { 
             Wire.beginTransmission(indevice);
             Wire.write(0x3D);
             Wire.write(0x96);
             Wire.endTransmission(true);
             if (LITERAL_mode ==1)
              {    
                Serial.println();
                Serial.print("完成RCO校准! ");
                Serial.println();
               }  
             delay(1500);
             }
        //***************************************************************************
        //-------------------------------------------------------------------------
        //扫描内部设置寄存器并显示保存在I2C中的设置   !!!
        //-------------------------------------------------------------------------
        int NOISEFLOOR;
        int SPIKEREJECTION; 
        int WATCHDOGTHRESHOLD; 
        
        if (LITERAL_mode ==1)
         {   
           Serial.print("设备寄存器[0X00]到[0x08]和[0x3A, 0X3B] ");
         }     
        //indevice = 3;
        for (int i=0; i<9; i++)
          { 
            Wire.beginTransmission(indevice);
            Wire.write(i); //要读取的地址  
            Wire.endTransmission(false);   //不释放线路!
            if (LITERAL_mode ==1)
              {   
               //Serial.print("设备寄存器[0X00]到[0x08]和[0x3A, 0X3B] "); 
               Serial.println();             
               Serial.print("寄存器地址 = 0x0");   
               Serial.print(i);               // 打印字符
            } 
            delay(200);
            Wire.requestFrom(indevice,1); // 从寄存器XY请求字节
             //-----------------------------------------------------------------------

            c=0;
            while(Wire.available())
              {
                 c = Wire.read();    // 接收字节作为字符
               if (i== 1)
                {
                 NOISEFLOOR= c;
                 NOISEFLOOR = NOISEFLOOR & (0b01110000);
                 NOISEFLOOR = NOISEFLOOR / 16; ; //右移4位。
                }
               if (i== 1)         
                {
                 SPIKEREJECTION= c;
                 SPIKEREJECTION = SPIKEREJECTION & (0b00001111);
                }
                if (i== 2)
                {
                  WATCHDOGTHRESHOLD= c;
                  WATCHDOGTHRESHOLD =  WATCHDOGTHRESHOLD & (0b00001111);
                }

               if (LITERAL_mode ==1)
               {        
                Serial.print(" *** 寄存器数据= [ ");         // 打印字符
                Serial.print((unsigned int)c);
                Serial.print(" ]");
               }   
             }
             delay(200);
          }
            //------------------------------------------------
            //主设置输出
            //------------------------------------------------
            if (LITERAL_mode ==1)
              {  
               Serial.println();
               Serial.println("*************************************************************************");
               Serial.println("* 这些寄存器影响系统检测图，根据需要修改 *");
               Serial.println("*************************************************************************");
               Serial.println();
               Serial.print("噪声基底设置: ");
               Serial.println(NOISEFLOOR,DEC);
               Serial.print("尖峰抑制是: ");
               Serial.println(SPIKEREJECTION,DEC);
               Serial.print("看门狗设定值是: ");
               Serial.println(WATCHDOGTHRESHOLD,DEC);
               }

         
            //----------------------------------
            //----------------------------------
            //---------------------------------------------------------------------------------
            //特殊寄存器设置   -------------------------------------------------------
            //---------------------------------------------------------------------------------
            // TRCO              = 0x3A  TRCO校准状态
            // bit7 =  TRCO_CALIB_DONE  TRCO校准完成（1=成功）
            // bit6 =  TRCO_CALIB_NOK   TRCO校准不成功（1=不成功）
            //---------------------------------------------------------------------------------  
            // SRCO              = 0X3B SRCO校准状态
            // bit7 =  SRCO_CALIB_DONE  TRCO校准完成（1=成功）
            // bit6 =  SRCO_CALIB_NOK   TRCO校准不成功（1=不成功）
            //---------------------------------------------------------------------------------
            if (LITERAL_mode ==1)
             { 
              Serial.println("*****************************************************");
              Serial.println("传感器校准状态:");
              Serial.println("*****************************************************");
              }
            Wire.beginTransmission(indevice);
            Wire.write(0x3A); //要读取的地址 
            Wire.endTransmission(false);   //不释放线路!
             if (LITERAL_mode ==1)
              { 
                Serial.println();        // 最后标签后的回车
                Serial.print("寄存器地址 = 0x3A");         // 打印字符
              }
            Wire.requestFrom(indevice,1); // 从寄存器XY请求字节
            //-------------------------------------------------------------------------
            c=0;
            while(Wire.available())
            {
               c = Wire.read();    // 接收字节作为字符
                if (LITERAL_mode ==1)
               {
                 Serial.print(" *** 寄存器数据= [ ");         // 打印字符
                 Serial.print(c, BIN);         // 打印字符 
                 Serial.print(" ]");
                 Serial.println();
                 c= c & 0b10000000;
                   if(c > 0)
                   Serial.print("< TRCO校准完成 >");         // 打印字符
                   if(c == 0)
                   Serial.print("< TRCO校准未完成 >");         // 打印字符
              }
             }
            delay(200);
            //-----------------------------------------------------------
            Wire.beginTransmission(indevice);
            Wire.write(0x3B); //要读取的地址 
            Wire.endTransmission(false);   //不释放线路!

            if (LITERAL_mode ==1)
             { 
               Serial.println();        // 最后标签后的回车
               Serial.print("寄存器地址 = 0x3B");         // 打印字符
              }
            Wire.requestFrom(indevice,1); // 从寄存器XY请求字节
            c=0;
            while(Wire.available())
             {
               c = Wire.read();    // 接收字节作为字符
                 if (LITERAL_mode ==1)
                  { 
                    Serial.print(" *** 寄存器数据= [ ");         // 打印字符
                    Serial.print(c,BIN);         // 打印字符 
                    Serial.print(" ]");
                    Serial.println();
                     c= c & 0b10000000;
                       if(c > 0)
                       Serial.print("< SRCO校准完成 >");             // 打印字符
                       if(c == 0)
                       Serial.print("< SRCO校准未完成 >");         // 打印字符
                    Serial.println();
                    Serial.println("*****************************************************");
                   }
            done =0;     //---------> 完成校准和内部寄存器设置退出"while循环"
            }
            delay(200);
        }
        delay(1000); 
     }
             //--------------------------------------------------------------------------
             //等待周期 - 无限 - 寻找闪电
             //操作周期中来自AS3935的变量
             //--------------------------------------------------------------------------
             int INT_struck ; //事件中断寄存器
             int N_lightning; //检测到的闪电数量
             int Av_distance; //平均距离估计
             int NOISE; //高噪声水平中断
             int Disturber; //检测到干扰器中断
             int L_struck; //检测到闪电中断
             int Distance; //估计命中距离
             int Energy_LSB; //单次事件能量低字节
             int Energy_MSB; //单次事件能量高字节
             int Energy_MMSB; //单次事件能量平均能量内容
             //-------------------------------------------------
             //-------------------------------------------------
             //图形缩放最小-最大: 根据您的喜好修改!!!
             //-------------------------------------------------
             int  MAX_scale =30;        //设置绘图的最大Y
             int  min_scale =0;         //设置绘图的最小Y
             //-------------------------------------------------
             //打印输出方法:
             //---------------------------------------------------------------------------
             //  LITERAL_mode =0;    //0= 在串行监视器上不打印数据
             //  GRAPH_mode   =1;    //1= 是在串行绘图器中打印图形数据
             //---------------------------------------------------------------------------
             //*****************************************
             //设置绘图器X-Y读数（X=时间）
             //*****************************************
            Serial.print("MAX"); //最大线标记
            Serial.print(" ");
            Serial.print("min");//最小线标记 
            Serial.print(" ");
            //*****************************************
            //设置标签名称
            //*****************************************
            Serial.print("NOISE");
            Serial.print(" ");
            Serial.print("Disturber");
            Serial.print(" ");
            Serial.print("Distance");
            Serial.print(" ");
            Serial.print("Energy_MSB/20");  //缩放因子/20
            Serial.print(" ");
            Serial.print("Energy_MMSB");
            //Serial.print(" ");
            Serial.println();
            //**************************************************
            //**************************************************
            // 开始无限事件观察周期
            //**************************************************
            //**************************************************
             while (1)
             {
               if (LITERAL_mode ==1)
              { 
               Serial.println();
               Serial.print(" *** 等待闪电 - 监视中 ");         // 打印字符
               Serial.println();
              } 
               //------------------------------------------------------------------------
               //感兴趣的寄存器读取!
               //------------------------------------------------------------------------               
           // indevice = 3;

               //------------------------------------------------------------------
               //检查寄存器0X03位= INT_L ---> "1000"上的传入INT消息
               //------------------------------------------------------------------
            Wire.beginTransmission(indevice);
            Wire.write(0x03); //要读取的地址
            Wire.endTransmission(false);   //不释放线路!
            Wire.requestFrom(indevice,1); // 从寄存器XY请求字节
            c=0;
            while(Wire.available())
            {
              //------------------------
              //清理变量
              //------------------------
              NOISE =0 ;
              Disturber =0;
              L_struck =0 ;
              Distance =0 ;
              Energy_LSB =0 ;
              Energy_MSB =0 ;
              Energy_MMSB =0 ;
              //------------------------
              c = Wire.read();    // 接收字节作为字符
              INT_struck = c;
              NOISE  =INT_struck & (0b00000001);
              Disturber  =INT_struck & (0b00000100);
              L_struck  =(INT_struck & (0b00001000))/8;  //这是一个标志位，所以可以是0或1。
             }
           //------------------------------------------------------------------------------------------------
           //调试所有!!!
           //------------------------------------------------------------------------------------------------
           // L_struck =1; --->   这显示所有消息，测试目的-AS3935系统调试删除"//"
           //
           //-------------------------------------------------------------------------------------------------
          if ((GRAPH_mode == 1) & (L_struck ==0))
            {
            //------------------------------------------------
            //图形-绘图器形式的事件读数
            //------------------------------------------------
          
            Serial.print(MAX_scale);
            Serial.print(" ");
            
            Serial.print(min_scale);
            Serial.print(" ");
            //Disturber=20;
            //Distance=30;
            //Energy_MMSB=40;
            //------------------------------------------------
            Serial.print(NOISE,DEC);
            Serial.print(" ");
            Serial.print(Disturber,DEC);
            Serial.print(" ");
            Serial.print(Distance,DEC);
            Serial.print(" ");
            //Serial.println(Energy_LSB,DEC);
            //Serial.print(" ");
            Energy_MSB = Energy_MSB/20;   //只是用于绘图的缩放因子!
            Serial.print(Energy_MSB,DEC);
            Serial.print(" ");
            Serial.print(Energy_MMSB,DEC);
            Serial.print(" ");
            Serial.println();
            } 
           //------------------------------------------------------------------------------
           if (L_struck > 0)
            {
          
           //----------------------------------------------------------------
           //距离估计 - 其他闪电数据 - 能量计算
           //----------------------------------------------------------------
           //距离:
           //---------------
            Wire.beginTransmission(indevice);
            Wire.write(0x07); //要读取的地址
            Wire.endTransmission(false);   //不释放线路!
            Wire.requestFrom(indevice,1); // 从寄存器XY请求字节
            c=0;
            while(Wire.available())
            {
            c = Wire.read();    // 接收字节作为字符
            Distance = c;
            Distance  = Distance & (0b00111111);
            }
            //-------------------------
            //能量LSB - MSB - 主要
            //-------------------------
            Wire.beginTransmission(indevice);
            Wire.write(0x04);              //要读取的地址
            Wire.endTransmission(false);   //不释放线路!
            Wire.requestFrom(indevice,1);  // 从寄存器XY请求字节
            c=0;
            while(Wire.available())
            {
            c = Wire.read();    // 接收字节作为字符
            Energy_LSB = c;
             }
            //-------------------------
            //能量MSB 
            //-------------------------
            Wire.beginTransmission(indevice);
           // Wire.requestFrom(indevice, 1);    // 从从设备请求1字节 
            Wire.write(0x05); //要读取的地址
            Wire.endTransmission(false);   //不释放线路!
            Wire.requestFrom(indevice,1); // 从寄存器XY请求字节
            c=0;
            while(Wire.available())
            {
            c = Wire.read();    // 接收字节作为字符
            Energy_MSB = c;
             }
            //-------------------------
            //能量MMSB 
            //-------------------------
            Wire.beginTransmission(indevice);
            Wire.write(0x06); //要读取的地址
            Wire.endTransmission(false);   //不释放线路!
            Wire.requestFrom(indevice,1); // 从寄存器XY请求字节
            c=0;
            while(Wire.available())
            {
            c = Wire.read();    // 接收字节作为字符
            Energy_MMSB = c;
            Energy_MMSB  = Energy_MMSB & (0b00011111);
            }
            //-------------------------------------------------------------------------
            //选择读出类型 完整数值数据或图形数据
            //-------------------------------------------------------------------------
            if (GRAPH_mode == 1)
            {
            //------------------------------------------------
            //事件读数的易读形式
            //------------------------------------------------
            Serial.print(MAX_scale);
            Serial.print(" ");
            
            Serial.print(min_scale);
            Serial.print(" ");
            //------------------------------------------------
            Serial.print(NOISE,DEC);
            Serial.print(" ");
            Serial.print(Disturber,DEC);
            Serial.print(" ");
            Serial.print(Distance,DEC);
            Serial.print(" ");
            //Serial.println(Energy_LSB,DEC);
            //Serial.print(" ");
            Energy_MSB = Energy_MSB/20;   //只是用于绘图的缩放因子!
            Serial.print(Energy_MSB,DEC);
            Serial.print(" ");
            Serial.print(Energy_MMSB,DEC);
            Serial.print(" ");
            Serial.println();
            } 
            if (LITERAL_mode == 1)
            {
            //------------------------------------------------
            //事件读数的易读形式
            //------------------------------------------------
            Serial.println();
            Serial.println("*****************************************************");
            Serial.println();
            Serial.print("检测到噪声水平: ");
            Serial.println(NOISE,DEC);
            Serial.print("检测到干扰器: ");
            Serial.println(Disturber,DEC);
            Serial.print("检测到闪电: ");
            Serial.println( L_struck,DEC);
            Serial.println();
            Serial.print("估计命中距离: ");
            Serial.println(Distance,DEC);
            Serial.print("LSB单次事件能量: ");
            Serial.println(Energy_LSB,DEC);
            Serial.print("MSB单次事件能量: ");
            Serial.println(Energy_MSB,DEC);
            Serial.print("MMSB单次事件能量: ");
            Serial.println(Energy_MMSB,DEC);
            } 
        //---------------------------------------------------------------------------------
        //-----------------------------------------------------------
        //清理旧数据寄存器，如果需要激活
        //用于最终应用
        //-----------------------------------------------------------
       if (false)  //替换为"true"激活!
        {
        //-------------------------------------
        //寄存器0X02:
        //-------------------------------------
         if (LITERAL_mode == 1)
           {
            Serial.println();
            Serial.print("写入寄存器0x02 ");
          }
         Wire.beginTransmission(indevice);
         Wire.write(0x02);
        //-------------------------------------------------
        //bit0..3 尖峰抑制 = 0010 (默认值)  --------> 更大的值提供更多抑制
        //                                                --------> 对干扰的抑制但降低敏感性
        //bit4..5 闪电数量 = 00 (默认值)
        //bit6   清除统计 = 1 (默认值)
        //字节 = 0 100 0010 (0x42 hex)
        //-------------------------------------------------
        //切换1-0-1重置统计
        //-------------------------------------------------
        Wire.write(REG0X02reset_startup_up);
        Wire.endTransmission(true);
        delay(200);
        //--------------------------
        Wire.write(REG0X02reset_startup_down);
        Wire.endTransmission(true);
        delay(200);
        //-------------------------
        Wire.write(REG0X02reset_startup_up);
        Wire.endTransmission(true);
        if (LITERAL_mode == 1)
          {
            Serial.println();
            Serial.print("完成! ");
            Serial.println();
          } 
        }
        delay(200);
        //------------------------------
        //------------------------------
        //------------------------------
      }         
     delay(1000);  // <------------- 扫描间隔 .... 根据需要修改!!!
             
    }

  }   
//-----------------------------------------------------------------------------
//------------------ 代码结束  -------------------------------------------
//-----------------------------------------------------------------------------
```

</details>

如果传感器检测到闪电，您将看到以下结果。

<div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Grove-lightning-sensor/4.png" style={{width:500, height:'auto'}}/></div>

为了测试目的，您可以使用打火机的点火器来模拟闪电，以检查传感器是否正常工作。

<div style={{textAlign:'center'}}><img src="https://files.seeedstudio.com/wiki/Grove-lightning-sensor/5.jpg" style={{width:600, height:'auto'}}/></div>

## 资源

- **[PDF]**[AS3935数据表](https://files.seeedstudio.com/wiki/Grove-lightning-sensor/AS3935_Datasheet_EN_v2.pdf)
- **[PDF]**[演示调谐示例](https://files.seeedstudio.com/wiki/Grove-lightning-sensor/Demo-Tuning_example.pdf)
- **[PDF]**[GROVE AS3935原理图 rev1](https://files.seeedstudio.com/wiki/Grove-lightning-sensor/SCHEMATIC-GROVE-AS3935-rev1.pdf)

## 技术支持和产品讨论

感谢您选择我们的产品！我们在这里为您提供不同的支持，以确保您使用我们产品的体验尽可能顺利。我们提供多个沟通渠道，以满足不同的偏好和需求。

<div class="button_tech_support_container">
<a href="https://forum.seeedstudio.com/" class="button_forum"></a> 
<a href="https://www.seeedstudio.com/contacts" class="button_email"></a>
</div>

<div class="button_tech_support_container">
<a href="https://discord.gg/eWkprNDMU7" class="button_discord"></a> 
<a href="https://github.com/Seeed-Studio/wiki-documents/discussions/69" class="button_discussion"></a>
</div>
